import{_ as a,c as s,o as i,a1 as n}from"./chunks/framework.t0t3spwR.js";const g=JSON.parse('{"title":"GPT-5.1-Codex-Max 提示词完全指南（通俗版）","description":"","frontmatter":{},"headers":[],"relativePath":"article/2025.12/4.md","filePath":"article/2025.12/4.md"}'),t={name:"article/2025.12/4.md"},l=n(`<h1 id="gpt-5-1-codex-max-提示词完全指南-通俗版" tabindex="-1">GPT-5.1-Codex-Max 提示词完全指南（通俗版） <a class="header-anchor" href="#gpt-5-1-codex-max-提示词完全指南-通俗版" aria-label="Permalink to &quot;GPT-5.1-Codex-Max 提示词完全指南（通俗版）&quot;">​</a></h1><h2 id="什么是-gpt-5-1-codex-max" tabindex="-1">什么是 GPT-5.1-Codex-Max <a class="header-anchor" href="#什么是-gpt-5-1-codex-max" aria-label="Permalink to &quot;什么是 GPT-5.1-Codex-Max&quot;">​</a></h2><p>GPT-5.1-Codex-Max 是 OpenAI 推出的最强代码生成模型，专为&quot;智能编码代理&quot;场景设计。简单来说，它不只是一个回答问题的 AI，而是能够像资深工程师一样<strong>自主完成整个开发任务</strong>——从理解需求、探索代码库、编写代码到测试验证，一气呵成。</p><h3 id="核心优势" tabindex="-1">核心优势 <a class="header-anchor" href="#核心优势" aria-label="Permalink to &quot;核心优势&quot;">​</a></h3><ul><li><p><strong>超强自主性</strong>：给它一个任务，它会主动收集信息、制定计划并执行，不需要你每一步都催促</p></li><li><p><strong>高效工具使用</strong>：内置优化的文件编辑、命令执行等工具，比传统方式快得多</p></li><li><p><strong>长上下文处理</strong>：通过&quot;压缩&quot;技术，可以处理超长对话和复杂项目</p></li><li><p><strong>更智能的并行操作</strong>：能同时执行多个操作，大幅提升效率</p></li></ul><h2 id="如何迁移到-codex-max" tabindex="-1">如何迁移到 Codex-Max <a class="header-anchor" href="#如何迁移到-codex-max" aria-label="Permalink to &quot;如何迁移到 Codex-Max&quot;">​</a></h2><p>如果你已经在使用旧版 Codex 或其他 AI 编码工具，迁移到 Codex-Max 需要两个关键步骤：</p><h3 id="步骤-1-更新你的提示词" tabindex="-1">步骤 1：更新你的提示词 <a class="header-anchor" href="#步骤-1-更新你的提示词" aria-label="Permalink to &quot;步骤 1：更新你的提示词&quot;">​</a></h3><p>OpenAI 提供了一套经过优化的<a href="https://github.com/openai/codex/blob/main/codex-rs/core/gpt-5.1-codex-max_prompt.md" target="_blank" rel="noreferrer">标准提示词模板</a>，建议以此为基础进行定制。</p><p><strong>重点关注以下部分：</strong></p><ul><li><p><strong>自主性和持久性</strong>：让模型知道它应该主动完成任务</p></li><li><p><strong>代码库探索</strong>：如何高效查找和阅读文件</p></li><li><p><strong>工具使用规范</strong>：优先使用专用工具，而非直接执行 shell 命令</p></li><li><p><strong>前端开发规范</strong>：避免生成&quot;AI 味&quot;太重的千篇一律界面</p></li></ul><p><strong>重要提醒</strong>：删除所有要求模型&quot;先说明计划&quot;或&quot;汇报进度&quot;的指令。Codex-Max 会自动通过推理摘要告知进度，额外的计划说明反而可能让它提前停止工作。</p><h3 id="步骤-2-更新你的工具集" tabindex="-1">步骤 2：更新你的工具集 <a class="header-anchor" href="#步骤-2-更新你的工具集" aria-label="Permalink to &quot;步骤 2：更新你的工具集&quot;">​</a></h3><p>工具配置是发挥 Codex-Max 性能的关键。务必采用 OpenAI 推荐的 <code>apply_patch</code> 实现和其他最佳实践。</p><h2 id="核心提示词解析" tabindex="-1">核心提示词解析 <a class="header-anchor" href="#核心提示词解析" aria-label="Permalink to &quot;核心提示词解析&quot;">​</a></h2><p>以下是标准提示词的关键部分，我们用通俗语言解释每一块的作用。</p><h3 id="自主性和持久性" tabindex="-1">自主性和持久性 <a class="header-anchor" href="#自主性和持久性" aria-label="Permalink to &quot;自主性和持久性&quot;">​</a></h3><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>你是一位自主的资深工程师：用户给出方向后，主动收集上下文、制定计划、实施、测试和完善，</span></span>
<span class="line"><span>无需在每一步等待额外提示。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>坚持到底：在当前回合内尽可能完整地处理任务——不要停留在分析或部分修复；</span></span>
<span class="line"><span>将更改贯穿实施、验证，并清楚说明结果，除非用户明确暂停或重定向你。</span></span></code></pre></div><p><strong>白话翻译</strong>：告诉模型&quot;你是老司机，接到活儿就自己干完，别干一半就停下来问我下一步怎么办&quot;。这样能大幅减少来回对话次数。</p><h3 id="代码实现原则" tabindex="-1">代码实现原则 <a class="header-anchor" href="#代码实现原则" aria-label="Permalink to &quot;代码实现原则&quot;">​</a></h3><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>作为一名挑剔的工程师：优化正确性、清晰度和可靠性，而非速度；</span></span>
<span class="line"><span>避免冒险的捷径、投机性更改和只是为了让代码运行的草率方案；</span></span>
<span class="line"><span>解决根本原因或核心需求，而不仅仅是症状或狭窄的一部分。</span></span></code></pre></div><p><strong>关键点</strong>：</p><ul><li><p><strong>严格错误处理</strong>：不要用宽泛的 <code>try/catch</code> 吞掉错误</p></li><li><p><strong>保持类型安全</strong>：避免 <code>as any</code> 这种偷懒做法</p></li><li><p><strong>代码复用</strong>：先搜索有没有现成的辅助函数，别重复造轮子</p></li><li><p><strong>批量编辑</strong>：一次性完成相关修改，别改一行提交一次</p></li></ul><h3 id="文件探索和并行读取" tabindex="-1">文件探索和并行读取 <a class="header-anchor" href="#文件探索和并行读取" aria-label="Permalink to &quot;文件探索和并行读取&quot;">​</a></h3><p>这是 Codex-Max 的一大亮点——<strong>批量并行读取文件</strong>。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>思考优先：在任何工具调用之前，决定你需要的所有文件/资源。</span></span>
<span class="line"><span>批量处理：如果需要多个文件（即使来自不同位置），一起读取它们。</span></span>
<span class="line"><span>使用 multi_tool_use.parallel 来并行化工具调用。</span></span></code></pre></div><p><strong>实际效果</strong>：传统 AI 可能逐个文件读取，每次等待你确认；Codex-Max 会一次性并行读取 10 个文件，速度快 10 倍！</p><p><strong>工作流程</strong>：</p><ol><li><p>分析任务，列出需要的所有文件</p></li><li><p>发起一个并行批次读取所有文件</p></li><li><p>分析结果</p></li><li><p>如果需要更多文件（基于前面的结果），重复步骤 1-3</p></li></ol><h3 id="计划工具使用规范" tabindex="-1">计划工具使用规范 <a class="header-anchor" href="#计划工具使用规范" aria-label="Permalink to &quot;计划工具使用规范&quot;">​</a></h3><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>对于简单任务（大约最简单的 25%），跳过使用计划工具。</span></span>
<span class="line"><span>不要制定单步计划。</span></span>
<span class="line"><span>完成计划中的子任务后，更新计划。</span></span>
<span class="line"><span>除非被要求制定计划，否则永远不要仅以计划结束互动。</span></span></code></pre></div><p><strong>核心思想</strong>：计划是用来指导自己的，不是用来&quot;交差&quot;的。复杂任务才需要计划，简单任务直接干。</p><h3 id="前端任务特别要求" tabindex="-1">前端任务特别要求 <a class="header-anchor" href="#前端任务特别要求" aria-label="Permalink to &quot;前端任务特别要求&quot;">​</a></h3><p>这部分非常有意思——专门防止生成&quot;AI 套话&quot;风格的界面：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>做前端设计任务时，避免陷入&quot;AI 俗套&quot;或安全、平庸的布局。</span></span>
<span class="line"><span>力求界面感觉有意图、大胆且有点令人惊喜。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- 排版：使用富有表现力、有目的的字体，避免默认字体栈（Inter、Roboto、Arial）</span></span>
<span class="line"><span>- 颜色和外观：选择明确的视觉方向；定义 CSS 变量；避免紫色加白色的默认配色。无紫色偏见或暗色模式偏见</span></span>
<span class="line"><span>- 动效：使用少量有意义的动画，而非通用的微动效</span></span>
<span class="line"><span>- 背景：不要依赖平面单色背景；使用渐变、形状或微妙的图案来营造氛围</span></span></code></pre></div><p><strong>警告</strong>：如果你是在现有设计系统中工作，则应保持原有风格，不要&quot;创新&quot;。</p><h3 id="呈现工作和最终消息" tabindex="-1">呈现工作和最终消息 <a class="header-anchor" href="#呈现工作和最终消息" aria-label="Permalink to &quot;呈现工作和最终消息&quot;">​</a></h3><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>你生成的是纯文本，稍后将由 CLI 进行样式处理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- 默认：非常简洁；友好的编码队友语气</span></span>
<span class="line"><span>- 格式：使用自然语言和高级标题</span></span>
<span class="line"><span>- 对于代码更改：先快速解释更改，然后详细说明上下文，包括在哪里以及为什么做出更改</span></span></code></pre></div><p><strong>关键规则</strong>：</p><ul><li><p>不要倾倒你写的大文件；仅引用路径</p></li><li><p>不要说&quot;保存/复制此文件&quot;——用户在同一台机器上</p></li><li><p>文件引用用内联代码格式，例如 <code>src/app.ts:42</code></p></li></ul><h2 id="compaction-压缩功能详解" tabindex="-1">Compaction 压缩功能详解 <a class="header-anchor" href="#compaction-压缩功能详解" aria-label="Permalink to &quot;Compaction 压缩功能详解&quot;">​</a></h2><p>这是 Codex-Max 的&quot;黑科技&quot;——让 AI 能处理超长对话而不会&quot;失忆&quot;。</p><h3 id="什么是-compaction" tabindex="-1">什么是 Compaction <a class="header-anchor" href="#什么是-compaction" aria-label="Permalink to &quot;什么是 Compaction&quot;">​</a></h3><p>想象你和 AI 对话了 100 轮，上下文窗口快满了。传统做法是删除旧对话或让 AI 变笨。Compaction 的做法是：把前面的对话&quot;压缩&quot;成更紧凑的形式，保留关键信息，但占用更少的 token。</p><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><ol><li><p>使用 Responses API 正常发送输入（包括工具调用、用户输入、助手消息）</p></li><li><p>当上下文窗口变大时，调用 <code>/compact</code> 端点生成压缩后的上下文</p></li><li><p>该端点返回一个 <code>encrypted_content</code> 项</p></li><li><p>在后续请求中传入这个压缩项，模型就能&quot;记住&quot;之前的状态</p></li></ol><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li><p>发送到 <code>/compact</code> 的上下文窗口必须在模型的上下文窗口限制内</p></li><li><p>返回的加密内容可以在未来请求中使用</p></li><li><p>模型能用更少的 token 保留关键的先前状态</p></li></ul><h2 id="工具使用最佳实践" tabindex="-1">工具使用最佳实践 <a class="header-anchor" href="#工具使用最佳实践" aria-label="Permalink to &quot;工具使用最佳实践&quot;">​</a></h2><h3 id="apply-patch-高效文件编辑" tabindex="-1">apply_patch：高效文件编辑 <a class="header-anchor" href="#apply-patch-高效文件编辑" aria-label="Permalink to &quot;apply_patch：高效文件编辑&quot;">​</a></h3><p>这是 Codex-Max 的核心工具，用于编辑文件。OpenAI 强烈建议使用他们的精确实现。</p><p><strong>为什么重要</strong>：模型经过专门训练来生成这种 diff 格式，使用标准实现能获得最佳效果。</p><p><strong>两种实现方式</strong>：</p><ol><li><p><strong>Responses API 内置工具</strong>（推荐）：直接在 API 中定义 <code>{&quot;type&quot;: &quot;apply_patch&quot;}</code></p></li><li><p><strong>自定义语法工具</strong>：使用上下文无关文法（CFG）定义</p></li></ol><p><strong>示例输出</strong>：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>*** Begin Patch</span></span>
<span class="line"><span>*** Update File: /app/page.tsx</span></span>
<span class="line"><span>@@</span></span>
<span class="line"><span> &lt;div&gt;</span></span>
<span class="line"><span>   &lt;p&gt;Page component not implemented&lt;/p&gt;</span></span>
<span class="line"><span>   &lt;button onclick=&quot;{()&quot; ==&quot;&quot;&gt; console.log(&quot;clicked&quot;)}&gt;Click me&lt;/button&gt;</span></span>
<span class="line"><span>+  &lt;button onclick=&quot;{()&quot; ==&quot;&quot;&gt; console.log(&quot;cancel clicked&quot;)}&gt;Cancel&lt;/button&gt;</span></span>
<span class="line"><span> &lt;/div&gt;</span></span>
<span class="line"><span> );</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span>*** End Patch</span></span></code></pre></div><h3 id="shell-command-执行命令" tabindex="-1">shell_command：执行命令 <a class="header-anchor" href="#shell-command-执行命令" aria-label="Permalink to &quot;shell_command：执行命令&quot;">​</a></h3><p>推荐的 shell 工具定义要点：</p><ul><li><p><strong>command 参数用字符串</strong>，不是命令列表（性能更好）</p></li><li><p><strong>始终设置 workdir</strong>，避免使用 <code>cd</code></p></li><li><p><strong>支持权限提升</strong>：通过 <code>with_escalated_permissions</code> 参数</p></li><li><p><strong>需要说明理由</strong>：如果需要提升权限，必须提供 <code>justification</code></p></li></ul><h3 id="update-plan-维护任务计划" tabindex="-1">update_plan：维护任务计划 <a class="header-anchor" href="#update-plan-维护任务计划" aria-label="Permalink to &quot;update_plan：维护任务计划&quot;">​</a></h3><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;explanation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;开始实现取消按钮功能&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;plan&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;step&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;添加取消按钮到页面&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;completed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;step&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;实现点击事件处理&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;in_progress&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;step&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;添加单元测试&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pending&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>最佳实践</strong>：</p><ul><li><p>简单任务不需要计划（约 25% 的最简单任务）</p></li><li><p>不要创建单步计划</p></li><li><p>完成子任务后及时更新状态</p></li><li><p>最多只能有一个 <code>in_progress</code> 步骤</p></li></ul><h2 id="自定义工具建议" tabindex="-1">自定义工具建议 <a class="header-anchor" href="#自定义工具建议" aria-label="Permalink to &quot;自定义工具建议&quot;">​</a></h2><p>如果你想添加自己的工具（如语义搜索、MCP 协议工具等），需要注意：</p><h3 id="命名规范" tabindex="-1">命名规范 <a class="header-anchor" href="#命名规范" aria-label="Permalink to &quot;命名规范&quot;">​</a></h3><ul><li><p><strong>语义明确</strong>：用 <code>semantic_search</code> 而不是模糊的 <code>search</code></p></li><li><p><strong>参数清晰</strong>：<code>query</code> 比 <code>text</code> 更能表达语义搜索的意图</p></li></ul><h3 id="输出格式" tabindex="-1">输出格式 <a class="header-anchor" href="#输出格式" aria-label="Permalink to &quot;输出格式&quot;">​</a></h3><p>让工具的输出看起来与模型习惯的格式不同。例如：</p><ul><li><p>Ripgrep 的搜索结果应该与语义搜索结果有明显区别</p></li><li><p>这样能避免模型&quot;混淆&quot;不同工具的用途</p></li></ul><h3 id="提示词指导" tabindex="-1">提示词指导 <a class="header-anchor" href="#提示词指导" aria-label="Permalink to &quot;提示词指导&quot;">​</a></h3><p>在系统提示中明确说明：</p><ul><li><p>何时使用这个工具</p></li><li><p>为什么使用（相比其他工具的优势）</p></li><li><p>如何使用（参数含义、预期输出）</p></li><li><p>提供好的和坏的使用示例</p></li></ul><h3 id="替代终端工具" tabindex="-1">替代终端工具 <a class="header-anchor" href="#替代终端工具" aria-label="Permalink to &quot;替代终端工具&quot;">​</a></h3><p>如果你希望模型使用专用工具而非直接调用终端命令，OpenAI 的建议是：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GIT_TOOL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;function&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;在仓库根目录执行 git 命令。行为类似在终端中运行 git&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;parameters&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;object&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;properties&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;command&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                &quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;要执行的 git 命令&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后在提示词中添加：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>严格避免在存在专用工具时使用原始 cmd/terminal。</span></span>
<span class="line"><span>优先使用专门工具：git（所有 git 操作）、list_dir、apply_patch。</span></span>
<span class="line"><span>只有在没有列出的工具可以执行操作时才使用 cmd/run_terminal_cmd。</span></span></code></pre></div><h2 id="并行工具调用技巧" tabindex="-1">并行工具调用技巧 <a class="header-anchor" href="#并行工具调用技巧" aria-label="Permalink to &quot;并行工具调用技巧&quot;">​</a></h2><p>启用并行工具调用后，在 Responses API 请求中设置 <code>parallel_tool_calls: true</code>，并在系统指令中添加：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>## 探索和读取文件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- **先思考**：在任何工具调用之前，决定你需要的所有文件/资源</span></span>
<span class="line"><span>- **批量处理所有内容**：如果需要多个文件（即使来自不同位置），一起读取它们</span></span>
<span class="line"><span>- **使用 multi_tool_use.parallel**：使用它来并行化工具调用，且仅使用它</span></span>
<span class="line"><span>- **只有在确实无法在不看到结果的情况下知道下一个文件时，才进行顺序调用**</span></span>
<span class="line"><span></span></span>
<span class="line"><span>额外注意事项：</span></span>
<span class="line"><span>- 始终最大化并行性。除非逻辑上不可避免，否则永远不要逐个读取文件</span></span>
<span class="line"><span>- 这涉及所有读取/列表/搜索操作，包括但不限于 cat、rg、sed、ls、git show、nl、wc 等</span></span>
<span class="line"><span>- 不要尝试使用脚本或 multi_tool_use.parallel 以外的任何方式来并行化</span></span></code></pre></div><h3 id="工具调用顺序" tabindex="-1">工具调用顺序 <a class="header-anchor" href="#工具调用顺序" aria-label="Permalink to &quot;工具调用顺序&quot;">​</a></h3><p>OpenAI 发现，按以下顺序排列并行工具调用项和响应更符合模型训练分布，效果更好：</p><ol><li><p>所有工具调用请求按逻辑分组</p></li><li><p>对应的工具响应紧随其后</p></li><li><p>保持调用和响应的配对清晰</p></li></ol><h3 id="响应截断建议" tabindex="-1">响应截断建议 <a class="header-anchor" href="#响应截断建议" aria-label="Permalink to &quot;响应截断建议&quot;">​</a></h3><p>为了保持与模型训练分布一致，建议按以下方式截断工具调用响应：</p><ul><li><p>保留错误消息的完整性</p></li><li><p>对超长输出进行智能截断（保留开头和结尾）</p></li><li><p>明确标注已截断的内容</p></li></ul><h2 id="推理摘要-不可提示" tabindex="-1">推理摘要（不可提示） <a class="header-anchor" href="#推理摘要-不可提示" aria-label="Permalink to &quot;推理摘要（不可提示）&quot;">​</a></h2><p>Codex 模型系列使用&quot;推理摘要&quot;在工作时向用户传达更新。这可以是单行标题（更新 Codex-CLI 中的临时文本），也可以是标题加简短正文。</p><p><strong>重要</strong>：这是由单独的模型完成的，因此<strong>不可通过提示词控制</strong>。OpenAI 建议不要在提示词中添加任何关于中间计划或用户消息的指令。</p><p>Codex-Max 改进了这些摘要，使其更具沟通性，提供关于正在发生的事情及原因的更多关键信息。</p><h2 id="上下文文件自动注入" tabindex="-1">上下文文件自动注入 <a class="header-anchor" href="#上下文文件自动注入" aria-label="Permalink to &quot;上下文文件自动注入&quot;">​</a></h2><p>Codex-cli 自动枚举这些文件并将它们注入到对话中；模型经过训练以严格遵守这些指令。</p><p><strong>工作原理</strong>：</p><ol><li><p>从 <code>~/.codex</code> 加上从仓库根目录到当前工作目录的每个目录中拉取文件</p></li><li><p>按顺序合并，后面的目录覆盖前面的目录</p></li><li><p>每个合并的块作为独立的用户角色消息显示给模型</p></li></ol><h2 id="实践建议总结" tabindex="-1">实践建议总结 <a class="header-anchor" href="#实践建议总结" aria-label="Permalink to &quot;实践建议总结&quot;">​</a></h2><h3 id="新手入门" tabindex="-1">新手入门 <a class="header-anchor" href="#新手入门" aria-label="Permalink to &quot;新手入门&quot;">​</a></h3><ol><li><p><strong>从官方模板开始</strong>：使用 OpenAI 的标准提示词模板，不要自己从零开始写</p></li><li><p><strong>克隆参考实现</strong>：下载 <a href="https://github.com/openai/codex" target="_blank" rel="noreferrer">codex-cli</a> 仓库，研究实际代码</p></li><li><p><strong>小步迭代</strong>：先让基础功能跑起来，再逐步定制</p></li></ol><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><ol><li><p><strong>用对工具</strong>：apply_patch、shell_command、update_plan 使用官方实现</p></li><li><p><strong>开启并行</strong>：设置 <code>parallel_tool_calls: true</code>，大幅提升速度</p></li><li><p><strong>合理压缩</strong>：长对话场景使用 Compaction 避免上下文溢出</p></li></ol><h3 id="常见陷阱" tabindex="-1">常见陷阱 <a class="header-anchor" href="#常见陷阱" aria-label="Permalink to &quot;常见陷阱&quot;">​</a></h3><ol><li><p><strong>过度指导</strong>：不要在提示词中要求模型&quot;先说计划再执行&quot;，这会降低自主性</p></li><li><p><strong>工具冲突</strong>：明确指示何时用专用工具，何时用 shell，避免混乱</p></li><li><p><strong>忽略并行</strong>：文件读取一定要批量并行，否则速度慢 10 倍</p></li></ol><h3 id="质量保证" tabindex="-1">质量保证 <a class="header-anchor" href="#质量保证" aria-label="Permalink to &quot;质量保证&quot;">​</a></h3><ol><li><p><strong>运行评估</strong>：针对答案正确性、完整性、工具使用正确性建立评测集</p></li><li><p><strong>提高自主性</strong>：评测时开启&quot;非交互模式&quot;，测试完全自主能力</p></li><li><p><strong>保持更新</strong>：关注 OpenAI 的 cookbook 和更新日志，及时采纳最佳实践</p></li></ol><h2 id="进阶话题" tabindex="-1">进阶话题 <a class="header-anchor" href="#进阶话题" aria-label="Permalink to &quot;进阶话题&quot;">​</a></h2><h3 id="windows-powershell-支持" tabindex="-1">Windows PowerShell 支持 <a class="header-anchor" href="#windows-powershell-支持" aria-label="Permalink to &quot;Windows PowerShell 支持&quot;">​</a></h3><p>如果使用 Windows PowerShell，需要更新 shell_command 工具描述以适配 PowerShell 语法。</p><h3 id="长生命周期-pty" tabindex="-1">长生命周期 PTY <a class="header-anchor" href="#长生命周期-pty" aria-label="Permalink to &quot;长生命周期 PTY&quot;">​</a></h3><p>对于需要流式输出、REPL 或交互式会话的场景，使用 <code>exec_command</code> 启动长期存活的 PTY，并用 <code>write_stdin</code> 向现有会话发送额外的按键输入。</p><h3 id="图像查看" tabindex="-1">图像查看 <a class="header-anchor" href="#图像查看" aria-label="Permalink to &quot;图像查看&quot;">​</a></h3><p>使用基础的 <code>view_image</code> 函数让模型能够查看图像，这在前端开发和 UI 调试中特别有用。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>GPT-5.1-Codex-Max 代表了 AI 编码辅助的新高度——从&quot;对话助手&quot;升级为&quot;自主工程师&quot;。要充分发挥其能力，关键在于：</p><ol><li><p><strong>信任自主性</strong>：给它任务，让它自己干完</p></li><li><p><strong>工具先行</strong>：使用官方推荐的工具实现</p></li><li><p><strong>批量思维</strong>：能并行就并行，别一个一个来</p></li><li><p><strong>持续优化</strong>：建立评测，迭代改进</p></li></ol><p>遵循本指南的最佳实践，你的 AI 编码代理将成为真正得力的开发伙伴。</p>`,115),p=[l];function e(o,h,r,d,c,u){return i(),s("div",null,p)}const q=a(t,[["render",e]]);export{g as __pageData,q as default};
